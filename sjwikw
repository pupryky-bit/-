def game(): global x, y, vx, vy, points, game_mode# Изменим координаты для перемещения мяча в кадреx, y = x + vx, y + vycanvas.coords( # этим методом холста перемещаем мячball, x - BALL_RADIUS, y - BALL_RADIUS,x + BALL_RADIUS, y + BALL_RADIUS)if y <= BALL_RADIUS: # если мяч коснулся верхней границы экранаvy = abs(vy) # движение мяча в положительном направлении# Похожим образом обрабатываем прикосновение мяча к краям по оси xif x <= BALL_RADIUS or x >= WIDTH - BALL_RADIUS:vx = -vx# Опишем отбив мяча платформойif x1 - PLATFORM_W // 2 <= x <= x1 + PLATFORM_W // 2 and \y == HEIGHT - (BALL_RADIUS + PLATFORM_H):vy = - vypoints += 1canvas.itemconfig(score, text=str(points))Здесь опишем удаление разбитого мячом кирпича: brick = get_brick() # получаем разбитый кирпичif brick:vy = - vy # Меняем направление движения мяча# Удаляем этот кирпичcanvas.delete(brick)bricks.pop(bricks.index(brick))points += 1 # Увеличим очки за разбитый кирпичcanvas.itemconfig(score, text=str(points))root.update()if y < (HEIGHT - BALL_RADIUS):root.after(TIMEOUT, game)else:game_mode = Falsecanvas.create_text(WIDTH // 2, HEIGHT // 2, text='GAME OVER',fill='red', font=(None, 50))def keyboard(event):global x1if event.keycode == 37:x1 -= 50if event.keycode == 39:x1 += 50if game_mode:canvas.coords(platform, x1 - PLATFORM_W // 2, HEIGHT,x1 + PLATFORM_W // 2, HEIGHT - PLATFORM_H)canvas.coords(score, x1, HEIGHT - PLATFORM_H // 2)def mouse_move(event):global x1x1 = event.xif game_mode:canvas.coords(platform, x1 - PLATFORM_W // 2, HEIGHT,x1 + PLATFORM_W // 2, HEIGHT - PLATFORM_H)canvas.coords(score, x1, HEIGHT - PLATFORM_H // 2)Далее мы опишем функцию, которая определяет какой кирпич нужно разбить:def get_brick():# В цикле перебираем все кирпичиfor brick in bricks:# Извлекаем координаты каждого кирпича# xb1, yb1 – левый верхний угол# xb2, yb2 – правый нижний уголxb1, yb1, xb2, yb2 = canvas.coords(brick)# Если центр мяча находится внутри пары координат кирпича# по горизонтали и вертикали, тогда - возвращаем этот кирпичif xb1 < x < xb2 and yb1 < y < yb2:return brickgame()root.bind('<Key>', keyboard)canvas.bind('<Motion>', mouse_move)root.mainloop()После запуска программы мы видим работоспособную программу: мяч движется, отражается от стенок и от платформы до тех пор, пока не коснётся нижней границы окна; количество выбитых очков отображается на самой платформе.На самом деле в нашей программе имеется серьёзный недостаток – нарушен принцип программирования DRY «не повторяйся». В двух функциях: keyboard() и mouse_move() имеется абсолютно одинаковые строки кода:if game_mode:canvas.coords(platform, x1 - PLATFORM_W // 2, HEIGHT,x1 + PLATFORM_W // 2, HEIGHT - PLATFORM_H)canvas.coords(score, x1, HEIGHT - PLATFORM_H // 2)Эти строки смещают платформу и отображают счёт на ней. Имеет смысл для выполнения этих действий реализовать отдельную функцию:def move_platform_and_score():if game_mode:canvas.coords(platform, x1 - PLATFORM_W // 2, HEIGHT,x1 + PLATFORM_W // 2, HEIGHT - PLATFORM_H)canvas.coords(score, x1, HEIGHT - PLATFORM_H // 2)Теперь, повторяющиеся строки кода удалим из функций, а вместо них сделаем вызов только что написанной функции:move_platform_and_score()
